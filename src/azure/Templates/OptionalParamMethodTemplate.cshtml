@using System.Linq;
@using AutoRest.Core.Model
@using AutoRest.Core.Utilities
@using AutoRest.Java
@using AutoRest.Java.Model
@inherits AutoRest.Core.Template<AutoRest.Java.Model.MethodJv>
@EmptyLine
/**
@if (!string.IsNullOrEmpty(Model.Summary))
{
@: * @Model.Summary.EscapeXmlComment().Period()
}
@if (!string.IsNullOrEmpty(Model.Description))
{
@: * @Model.Description.EscapeXmlComment().Period()
}
 *
@foreach (var param in Model.LocalParameters.Where(p => !p.IsConstant && p.IsRequired))
{
@: * @@param @param.Name @(param.Documentation.Else("the " + param.ModelType.Name + " value").EscapeXmlComment().Trim())
}
 * @@param @(Model.Name.ToCamelCase())OptionalParameter the object representing the optional parameters to be set before calling this API
 * @@throws IllegalArgumentException thrown if parameters fail the validation
 * @@throws @Model.OperationExceptionTypeString thrown if the request is rejected by server
 * @@throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
@if (Model.ReturnType.Body != null)
{
@: * @@return the @Model.ReturnTypeResponseName.EscapeXmlComment() object if successful.
}
 */
public @Model.ReturnTypeResponseName @(Model.Name)(@Model.MethodOptionalParameterDeclaration) {
@if (@Model.ReturnTypeResponseName == "void")
{
@:    @(Model.Name)WithServiceResponseAsync(@Model.MethodOptionalParameterInvocation).toBlocking().single().body();
}
else
{
@:    return @(Model.Name)WithServiceResponseAsync(@Model.MethodOptionalParameterInvocation).toBlocking().single().body();
}
}
@EmptyLine
/**
@if (!string.IsNullOrEmpty(Model.Summary))
{
@: * @Model.Summary.EscapeXmlComment().Period()
}
@if (!string.IsNullOrEmpty(Model.Description))
{
@: * @Model.Description.EscapeXmlComment().Period()
}
 *
@foreach (var param in Model.LocalParameters.Where(p => !p.IsConstant && p.IsRequired))
{
@: * @@param @param.Name @(param.Documentation.Else("the " + param.ModelType.Name + " value").EscapeXmlComment().Trim())
}
 * @@param @(Model.Name.ToCamelCase())OptionalParameter the object representing the optional parameters to be set before calling this API
@Model.CallbackDocumentation
 * @@throws IllegalArgumentException thrown if parameters fail the validation
 * @@return the {@@link ServiceFuture} object
 */
public ServiceFuture<@Model.ReturnTypeJv.ServiceFutureGenericParameterString> @(Model.Name)Async(@Model.MethodOptionalParameterDeclarationWithCallback) {
    return ServiceFuture.@(Model.ServiceFutureFactoryMethod)(@(Model.Name)WithServiceResponseAsync(@Model.MethodOptionalParameterInvocation), serviceCallback);
}
@EmptyLine
/**
@if (!string.IsNullOrEmpty(Model.Summary))
{
@: * @Model.Summary.EscapeXmlComment().Period()
}
@if (!string.IsNullOrEmpty(Model.Description))
{
@: * @Model.Description.EscapeXmlComment().Period()
}
 *
@foreach (var param in Model.LocalParameters.Where(p => !p.IsConstant && p.IsRequired))
{
@: * @@param @param.Name @(param.Documentation.Else("the " + param.ModelType.Name + " value").EscapeXmlComment().Trim())
}
 * @@param @(Model.Name.ToCamelCase())OptionalParameter the object representing the optional parameters to be set before calling this API
 * @@throws IllegalArgumentException thrown if parameters fail the validation
@if (Model.ReturnType.Body != null)
{
@: * @@return the observable to the @Model.ReturnTypeJv.GenericBodyClientTypeString.EscapeXmlComment() object
}
else
{
@: * @@return the {@@link @Model.ReturnTypeJv.ClientResponseType} object if successful.
}
 */
public Observable<@Model.ReturnTypeJv.GenericBodyClientTypeString> @(Model.Name)Async(@Model.MethodOptionalParameterDeclaration) {
    return @(Model.Name)WithServiceResponseAsync(@Model.MethodOptionalParameterInvocation).map(new Func1<@Model.ReturnTypeJv.ClientResponseTypeString, @Model.ReturnTypeJv.GenericBodyClientTypeString>() {
        @@Override
        public @Model.ReturnTypeJv.GenericBodyClientTypeString call(@Model.ReturnTypeJv.ClientResponseTypeString response) {
            return response.body();
        }
    });
}
@EmptyLine
/**
@if (!string.IsNullOrEmpty(Model.Summary))
{
@: * @Model.Summary.EscapeXmlComment().Period()
}
@if (!string.IsNullOrEmpty(Model.Description))
{
@: * @Model.Description.EscapeXmlComment().Period()
}
 *
@foreach (var param in Model.LocalParameters.Where(p => !p.IsConstant && p.IsRequired))
{
@: * @@param @param.Name @(param.Documentation.Else("the " + param.ModelType.Name + " value").EscapeXmlComment().Trim())
}
 * @@param @(Model.Name.ToCamelCase())OptionalParameter the object representing the optional parameters to be set before calling this API
 * @@throws IllegalArgumentException thrown if parameters fail the validation
@if (Model.ReturnType.Body != null)
{
@: * @@return the observable to the @Model.ReturnTypeJv.GenericBodyClientTypeString.EscapeXmlComment() object
}
else
{
@: * @@return the {@@link @Model.ReturnTypeJv.ClientResponseType} object if successful.
}
 */
public Observable<@Model.ReturnTypeJv.ClientResponseTypeString> @(Model.Name)WithServiceResponseAsync(@Model.MethodOptionalParameterDeclaration) {
@foreach (var param in Model.RequiredNullableParameters)
{
@:    if (@param.Name == null) {
@:        throw new IllegalArgumentException("Parameter @param.Name is required and cannot be null.");
@:    }
}
@foreach (var param in Model.ParametersToValidate.Where(p => p.IsRequired))
{
@:    Validator.validate(@(param.Name));
}
@foreach (ParameterJv parameter in Model.LocalParameters)
{
if (!parameter.IsRequired)
{
if (parameter.Name == "userAgent")
{
@:    final @(parameter.ClientType.Name) @(parameter.Name) = @(Model.Name.ToCamelCase())OptionalParameter != null ? @(Model.Name.ToCamelCase())OptionalParameter.@(parameter.Name)() : @(parameter.ClientType.GetDefaultValue(Model) ?? "this.client.userAgent()");
}
else
{
if (parameter.IsConstant)
{
@:    final @(parameter.ClientType.Name) @(parameter.Name) = @(parameter.DefaultValue ?? "null");

}
else
{
@:    final @(parameter.ClientType.Name) @(parameter.Name) = @(Model.Name.ToCamelCase())OptionalParameter != null ? @(Model.Name.ToCamelCase())OptionalParameter.@(parameter.Name)() : @(parameter.ClientType.GetDefaultValue(Model) ?? "null");
}
}
}
}
@EmptyLine
    return @(Model.Name)WithServiceResponseAsync(@Model.MethodParameterInvocation);
}
@EmptyLine
/**
@if (!string.IsNullOrEmpty(Model.Summary))
{
@: * @Model.Summary.EscapeXmlComment().Period()
}
@if (!string.IsNullOrEmpty(Model.Description))
{
@: * @Model.Description.EscapeXmlComment().Period()
}
 *
@foreach (var param in Model.LocalParameters.Where(p => !p.IsConstant))
{
@: * @@param @param.Name @(param.Documentation.Else("the " + param.ModelType.Name + " value").EscapeXmlComment().Trim())
}
 * @@throws IllegalArgumentException thrown if parameters fail the validation
@if (Model.ReturnType.Body != null)
{
@: * @@return the observable to the @Model.ReturnTypeJv.GenericBodyClientTypeString.EscapeXmlComment() object
}
else
{
@: * @@return the {@@link @Model.ReturnTypeJv.ClientResponseType} object if successful.
}
 */
public Observable<@Model.ReturnTypeJv.ClientResponseTypeString> @(Model.Name)WithServiceResponseAsync(@Model.MethodParameterDeclaration) {
@foreach (var param in Model.RequiredNullableParameters)
{
@:    if (@param.Name == null) {
@:        throw new IllegalArgumentException("Parameter @param.Name is required and cannot be null.");
@:    }
}
@foreach (var param in Model.ParametersToValidate)
{
@:    Validator.validate(@(param.Name));
}
@foreach (ParameterJv parameter in Model.LocalParameters)
{
    if (parameter.IsConstant)
    {
@:    final @(parameter.ModelType.Name) @(parameter.Name) = @(parameter.DefaultValue ?? "null");
    }
}
    @Model.BuildInputMappings()

@if (Model.IsParameterizedHost)
{
@:    String parameterizedHost = Joiner.on(", ").join(@Model.HostParameterReplacementArgs);
}
    @Model.ParameterConversion
    return service.@(Model.Name)(@Model.MethodParameterApiInvocation)
        .flatMap(new Func1<Response<@Model.CallType>, Observable<@(Model.ReturnTypeJv.ClientResponseTypeString)>>() {
            @@Override
            public Observable<@(Model.ReturnTypeJv.ClientResponseTypeString)> call(Response<@Model.CallType> response) {
                try {
                    @Model.ClientResponse()
                    return Observable.just(clientResponse);
                } catch (Throwable t) {
                    return Observable.error(t);
                }
            }
        });
}
@EmptyLine
private @Model.ReturnTypeJv.WireResponseTypeString @(Model.Name)Delegate(Response<@Model.CallType> response) throws @Model.ExceptionString {
    return @(Model.ClientReference).restClient().responseBuilderFactory().<@Model.ReturnTypeJv.GenericBodyWireTypeString, @Model.OperationExceptionTypeString>newInstance(@(Model.ClientReference).serializerAdapter())
@foreach (var response in Model.Responses)
{

            @:.register(@((int)response.Key), new TypeToken<@((response.Value as ResponseJv).GenericBodyWireTypeString)>() { }.getType())
}
@if (Model.DefaultResponse.Body != null)
{
            @:.registerError(@(Model.OperationExceptionTypeString).class)
}
@if (Model.HttpMethod == HttpMethod.Head)
{
    if (Model.ReturnType.Headers != null)
    {
            @:.buildEmptyWithHeaders(response, @(Model.ReturnType.Headers.Name).class);
    }
    else
    {
            @:.buildEmpty(response);
    }
}
else
{
    if (Model.ReturnType.Headers != null)
    {
            @:.buildWithHeaders(response, @(Model.ReturnType.Headers.Name).class);
    }
    else
    {
            @:.build(response);
    }
}
}
@if (true == AutoRest.Core.Settings.Instance.Host?.GetValue<bool?>("with-expanded-parameters").Result)
{
@EmptyLine
@:@@Override
@:public @(Model.Extensions["ParametersClassName"]) @(Model.Name)() {
@:    return new @(Model.Extensions["ParametersClassName"])(this);
@:}
@EmptyLine
@:/**
@: * Internal class implementing @(Model.Extensions["InterfaceDefinition"]).
@: */
@:class @(Model.Extensions["ParametersClassName"].ToString()) implements @(Model.Extensions["InterfaceDefinition"].ToString()) {
@:    private @(Model.MethodGroup.TypeName.ToPascalCase())Impl parent;
foreach (var param in Model.LocalParameters.Where(p => !p.IsConstant))
{
@:    private @(param.ClientType.ParameterVariant.Name) @(param.Name);
}
@EmptyLine
@:    /**
@:     * Constructor.
@:     * @@param parent the parent object.
@:     */
@:    @(Model.Extensions["ParametersClassName"].ToString())(@(Model.MethodGroup.TypeName.ToPascalCase())Impl parent) {
@:        this.parent = parent;
@:    }
@EmptyLine
foreach (var param in Model.LocalParameters.Where(p => !p.IsConstant))
{
@:    @@Override
@:    public @(Model.Extensions["ParametersClassName"].ToString()) @(param.Extensions["InterfaceMethodName"])(@(param.ClientType.ParameterVariant.Name) @(param.Name)) {
@:        this.@(param.Name) = @(param.Name);
@:        return this;
@:    }
@EmptyLine
}
@:    @@Override
@:    public @Model.ReturnTypeResponseName execute() {
@if (@Model.ReturnTypeResponseName == "void")
{
@:    @(Model.Name)WithServiceResponseAsync(@Model.MethodParameterInvocation).toBlocking().single().body();
}
else
{
@:    return @(Model.Name)WithServiceResponseAsync(@Model.MethodParameterInvocation).toBlocking().single().body();
}
@:}
@EmptyLine
@:    @@Override
@:    public Observable<@Model.ReturnTypeJv.GenericBodyClientTypeString> executeAsync() {
@:        return @(Model.Name)WithServiceResponseAsync(@Model.MethodParameterInvocation).map(new Func1<@Model.ReturnTypeJv.ClientResponseTypeString, @Model.ReturnTypeJv.GenericBodyClientTypeString>() {
@:            @@Override
@:            public @Model.ReturnTypeJv.GenericBodyClientTypeString call(@Model.ReturnTypeJv.ClientResponseTypeString response) {
@:                return response.body();
@:            }
@:        });
@:    }
@:}
}
