/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package fixtures.http.implementation;

import com.microsoft.rest.RestProxy;
import fixtures.http.HttpRedirects;
import com.google.common.reflect.TypeToken;
import com.microsoft.rest.annotations.BodyParam;
import com.microsoft.rest.annotations.DELETE;
import com.microsoft.rest.annotations.ExpectedResponses;
import com.microsoft.rest.annotations.GET;
import com.microsoft.rest.annotations.HEAD;
import com.microsoft.rest.annotations.Headers;
import com.microsoft.rest.annotations.Host;
import com.microsoft.rest.annotations.PATCH;
import com.microsoft.rest.annotations.POST;
import com.microsoft.rest.annotations.PUT;
import com.microsoft.rest.annotations.UnexpectedResponseExceptionType;
import com.microsoft.rest.http.HttpClient;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import fixtures.http.models.ErrorException;
import fixtures.http.models.HttpRedirectsDelete307Headers;
import fixtures.http.models.HttpRedirectsGet300Headers;
import fixtures.http.models.HttpRedirectsGet301Headers;
import fixtures.http.models.HttpRedirectsGet302Headers;
import fixtures.http.models.HttpRedirectsGet307Headers;
import fixtures.http.models.HttpRedirectsHead300Headers;
import fixtures.http.models.HttpRedirectsHead301Headers;
import fixtures.http.models.HttpRedirectsHead302Headers;
import fixtures.http.models.HttpRedirectsHead307Headers;
import fixtures.http.models.HttpRedirectsPatch302Headers;
import fixtures.http.models.HttpRedirectsPatch307Headers;
import fixtures.http.models.HttpRedirectsPost303Headers;
import fixtures.http.models.HttpRedirectsPost307Headers;
import fixtures.http.models.HttpRedirectsPut301Headers;
import fixtures.http.models.HttpRedirectsPut307Headers;
import java.io.IOException;
import java.util.List;
import rx.functions.Func1;
import rx.Observable;
import rx.Single;

/**
 * An instance of this class provides access to all the operations defined
 * in HttpRedirects.
 */
public class HttpRedirectsImpl implements HttpRedirects {
    /** The RestProxy service to perform REST calls. */
    private HttpRedirectsService service;
    /** The service client containing this operation class. */
    private AutoRestHttpInfrastructureTestServiceImpl client;

    /**
     * Initializes an instance of HttpRedirects.
     *
     * @param client the instance of the service client containing this operation class.
     */
    public HttpRedirectsImpl(AutoRestHttpInfrastructureTestServiceImpl client) {
        this.service = RestProxy.create(HttpRedirectsService.class, client.restClient().baseURL(), client.httpClient(), client.serializerAdapter());
        this.client = client;
    }

    /**
     * The interface defining all the services for HttpRedirects to be
     * used by RestProxy to perform REST calls.
    */
    @Host("http://localhost")
    interface HttpRedirectsService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.http.HttpRedirects head300" })
        @HEAD("http/redirect/300")
        @ExpectedResponses({200, 300})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<Void> head300();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.http.HttpRedirects get300" })
        @GET("http/redirect/300")
        @ExpectedResponses({200, 300})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<List<String>> get300();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.http.HttpRedirects head301" })
        @HEAD("http/redirect/301")
        @ExpectedResponses({200, 301})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<Void> head301();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.http.HttpRedirects get301" })
        @GET("http/redirect/301")
        @ExpectedResponses({200, 301})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<Void> get301();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.http.HttpRedirects put301" })
        @PUT("http/redirect/301")
        @ExpectedResponses({301})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<Void> put301(@BodyParam Boolean booleanValue);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.http.HttpRedirects head302" })
        @HEAD("http/redirect/302")
        @ExpectedResponses({200, 302})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<Void> head302();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.http.HttpRedirects get302" })
        @GET("http/redirect/302")
        @ExpectedResponses({200, 302})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<Void> get302();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.http.HttpRedirects patch302" })
        @PATCH("http/redirect/302")
        @ExpectedResponses({302})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<Void> patch302(@BodyParam Boolean booleanValue);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.http.HttpRedirects post303" })
        @POST("http/redirect/303")
        @ExpectedResponses({200, 303})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<Void> post303(@BodyParam Boolean booleanValue);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.http.HttpRedirects head307" })
        @HEAD("http/redirect/307")
        @ExpectedResponses({200, 307})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<Void> head307();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.http.HttpRedirects get307" })
        @GET("http/redirect/307")
        @ExpectedResponses({200, 307})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<Void> get307();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.http.HttpRedirects put307" })
        @PUT("http/redirect/307")
        @ExpectedResponses({200, 307})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<Void> put307(@BodyParam Boolean booleanValue);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.http.HttpRedirects patch307" })
        @PATCH("http/redirect/307")
        @ExpectedResponses({200, 307})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<Void> patch307(@BodyParam Boolean booleanValue);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.http.HttpRedirects post307" })
        @POST("http/redirect/307")
        @ExpectedResponses({200, 307})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<Void> post307(@BodyParam Boolean booleanValue);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.http.HttpRedirects delete307" })
        @DELETE("http/redirect/307")
        @ExpectedResponses({200, 307})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<Void> delete307(@BodyParam Boolean booleanValue);

    }

    /**
     * Return 300 status code and redirect to /http/success/200.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void head300() {
        head300Async().toBlocking().value();
    }

    /**
     * Return 300 status code and redirect to /http/success/200.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> head300Async(final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody/* RestProxy doesn't support headers */(head300Async(), serviceCallback);
    }

    /**
     * Return 300 status code and redirect to /http/success/200.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link Single<Void>} object if successful.
     */
    public Single<Void> head300Async() {
        return service.head300();
    }


    /**
     * Return 300 status code and redirect to /http/success/200.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;String&gt; object if successful.
     */
    public List<String> get300() {
        return get300Async().toBlocking().value();
    }

    /**
     * Return 300 status code and redirect to /http/success/200.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<String>> get300Async(final ServiceCallback<List<String>> serviceCallback) {
        return ServiceFuture.fromBody/* RestProxy doesn't support headers */(get300Async(), serviceCallback);
    }

    /**
     * Return 300 status code and redirect to /http/success/200.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;String&gt; object
     */
    public Single<List<String>> get300Async() {
        return service.get300();
    }


    /**
     * Return 301 status code and redirect to /http/success/200.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void head301() {
        head301Async().toBlocking().value();
    }

    /**
     * Return 301 status code and redirect to /http/success/200.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> head301Async(final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody/* RestProxy doesn't support headers */(head301Async(), serviceCallback);
    }

    /**
     * Return 301 status code and redirect to /http/success/200.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link Single<Void>} object if successful.
     */
    public Single<Void> head301Async() {
        return service.head301();
    }


    /**
     * Return 301 status code and redirect to /http/success/200.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void get301() {
        get301Async().toBlocking().value();
    }

    /**
     * Return 301 status code and redirect to /http/success/200.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> get301Async(final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody/* RestProxy doesn't support headers */(get301Async(), serviceCallback);
    }

    /**
     * Return 301 status code and redirect to /http/success/200.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link Single<Void>} object if successful.
     */
    public Single<Void> get301Async() {
        return service.get301();
    }


    /**
     * Put true Boolean value in request returns 301.  This request should not be automatically redirected, but should return the received 301 to the caller for evaluation.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void put301() {
        put301Async().toBlocking().value();
    }

    /**
     * Put true Boolean value in request returns 301.  This request should not be automatically redirected, but should return the received 301 to the caller for evaluation.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> put301Async(final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody/* RestProxy doesn't support headers */(put301Async(), serviceCallback);
    }

    /**
     * Put true Boolean value in request returns 301.  This request should not be automatically redirected, but should return the received 301 to the caller for evaluation.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link Void} object if successful.
     */
    public Single<Void> put301Async() {
        final Boolean booleanValue = null;
        return service.put301(booleanValue);
    }

    /**
     * Put true Boolean value in request returns 301.  This request should not be automatically redirected, but should return the received 301 to the caller for evaluation.
     *
     * @param booleanValue Simple boolean value true
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void put301(Boolean booleanValue) {
        put301Async(booleanValue).toBlocking().value();
    }

    /**
     * Put true Boolean value in request returns 301.  This request should not be automatically redirected, but should return the received 301 to the caller for evaluation.
     *
     * @param booleanValue Simple boolean value true
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> put301Async(Boolean booleanValue, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody/* RestProxy doesn't support headers */(put301Async(booleanValue), serviceCallback);
    }

    /**
     * Put true Boolean value in request returns 301.  This request should not be automatically redirected, but should return the received 301 to the caller for evaluation.
     *
     * @param booleanValue Simple boolean value true
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link Single<Void>} object if successful.
     */
    public Single<Void> put301Async(Boolean booleanValue) {
        return service.put301(booleanValue);
    }


    /**
     * Return 302 status code and redirect to /http/success/200.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void head302() {
        head302Async().toBlocking().value();
    }

    /**
     * Return 302 status code and redirect to /http/success/200.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> head302Async(final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody/* RestProxy doesn't support headers */(head302Async(), serviceCallback);
    }

    /**
     * Return 302 status code and redirect to /http/success/200.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link Single<Void>} object if successful.
     */
    public Single<Void> head302Async() {
        return service.head302();
    }


    /**
     * Return 302 status code and redirect to /http/success/200.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void get302() {
        get302Async().toBlocking().value();
    }

    /**
     * Return 302 status code and redirect to /http/success/200.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> get302Async(final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody/* RestProxy doesn't support headers */(get302Async(), serviceCallback);
    }

    /**
     * Return 302 status code and redirect to /http/success/200.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link Single<Void>} object if successful.
     */
    public Single<Void> get302Async() {
        return service.get302();
    }


    /**
     * Patch true Boolean value in request returns 302.  This request should not be automatically redirected, but should return the received 302 to the caller for evaluation.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void patch302() {
        patch302Async().toBlocking().value();
    }

    /**
     * Patch true Boolean value in request returns 302.  This request should not be automatically redirected, but should return the received 302 to the caller for evaluation.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> patch302Async(final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody/* RestProxy doesn't support headers */(patch302Async(), serviceCallback);
    }

    /**
     * Patch true Boolean value in request returns 302.  This request should not be automatically redirected, but should return the received 302 to the caller for evaluation.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link Void} object if successful.
     */
    public Single<Void> patch302Async() {
        final Boolean booleanValue = null;
        return service.patch302(booleanValue);
    }

    /**
     * Patch true Boolean value in request returns 302.  This request should not be automatically redirected, but should return the received 302 to the caller for evaluation.
     *
     * @param booleanValue Simple boolean value true
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void patch302(Boolean booleanValue) {
        patch302Async(booleanValue).toBlocking().value();
    }

    /**
     * Patch true Boolean value in request returns 302.  This request should not be automatically redirected, but should return the received 302 to the caller for evaluation.
     *
     * @param booleanValue Simple boolean value true
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> patch302Async(Boolean booleanValue, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody/* RestProxy doesn't support headers */(patch302Async(booleanValue), serviceCallback);
    }

    /**
     * Patch true Boolean value in request returns 302.  This request should not be automatically redirected, but should return the received 302 to the caller for evaluation.
     *
     * @param booleanValue Simple boolean value true
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link Single<Void>} object if successful.
     */
    public Single<Void> patch302Async(Boolean booleanValue) {
        return service.patch302(booleanValue);
    }


    /**
     * Post true Boolean value in request returns 303.  This request should be automatically redirected usign a get, ultimately returning a 200 status code.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void post303() {
        post303Async().toBlocking().value();
    }

    /**
     * Post true Boolean value in request returns 303.  This request should be automatically redirected usign a get, ultimately returning a 200 status code.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> post303Async(final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody/* RestProxy doesn't support headers */(post303Async(), serviceCallback);
    }

    /**
     * Post true Boolean value in request returns 303.  This request should be automatically redirected usign a get, ultimately returning a 200 status code.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link Void} object if successful.
     */
    public Single<Void> post303Async() {
        final Boolean booleanValue = null;
        return service.post303(booleanValue);
    }

    /**
     * Post true Boolean value in request returns 303.  This request should be automatically redirected usign a get, ultimately returning a 200 status code.
     *
     * @param booleanValue Simple boolean value true
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void post303(Boolean booleanValue) {
        post303Async(booleanValue).toBlocking().value();
    }

    /**
     * Post true Boolean value in request returns 303.  This request should be automatically redirected usign a get, ultimately returning a 200 status code.
     *
     * @param booleanValue Simple boolean value true
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> post303Async(Boolean booleanValue, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody/* RestProxy doesn't support headers */(post303Async(booleanValue), serviceCallback);
    }

    /**
     * Post true Boolean value in request returns 303.  This request should be automatically redirected usign a get, ultimately returning a 200 status code.
     *
     * @param booleanValue Simple boolean value true
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link Single<Void>} object if successful.
     */
    public Single<Void> post303Async(Boolean booleanValue) {
        return service.post303(booleanValue);
    }


    /**
     * Redirect with 307, resulting in a 200 success.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void head307() {
        head307Async().toBlocking().value();
    }

    /**
     * Redirect with 307, resulting in a 200 success.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> head307Async(final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody/* RestProxy doesn't support headers */(head307Async(), serviceCallback);
    }

    /**
     * Redirect with 307, resulting in a 200 success.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link Single<Void>} object if successful.
     */
    public Single<Void> head307Async() {
        return service.head307();
    }


    /**
     * Redirect get with 307, resulting in a 200 success.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void get307() {
        get307Async().toBlocking().value();
    }

    /**
     * Redirect get with 307, resulting in a 200 success.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> get307Async(final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody/* RestProxy doesn't support headers */(get307Async(), serviceCallback);
    }

    /**
     * Redirect get with 307, resulting in a 200 success.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link Single<Void>} object if successful.
     */
    public Single<Void> get307Async() {
        return service.get307();
    }


    /**
     * Put redirected with 307, resulting in a 200 after redirect.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void put307() {
        put307Async().toBlocking().value();
    }

    /**
     * Put redirected with 307, resulting in a 200 after redirect.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> put307Async(final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody/* RestProxy doesn't support headers */(put307Async(), serviceCallback);
    }

    /**
     * Put redirected with 307, resulting in a 200 after redirect.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link Void} object if successful.
     */
    public Single<Void> put307Async() {
        final Boolean booleanValue = null;
        return service.put307(booleanValue);
    }

    /**
     * Put redirected with 307, resulting in a 200 after redirect.
     *
     * @param booleanValue Simple boolean value true
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void put307(Boolean booleanValue) {
        put307Async(booleanValue).toBlocking().value();
    }

    /**
     * Put redirected with 307, resulting in a 200 after redirect.
     *
     * @param booleanValue Simple boolean value true
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> put307Async(Boolean booleanValue, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody/* RestProxy doesn't support headers */(put307Async(booleanValue), serviceCallback);
    }

    /**
     * Put redirected with 307, resulting in a 200 after redirect.
     *
     * @param booleanValue Simple boolean value true
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link Single<Void>} object if successful.
     */
    public Single<Void> put307Async(Boolean booleanValue) {
        return service.put307(booleanValue);
    }


    /**
     * Patch redirected with 307, resulting in a 200 after redirect.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void patch307() {
        patch307Async().toBlocking().value();
    }

    /**
     * Patch redirected with 307, resulting in a 200 after redirect.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> patch307Async(final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody/* RestProxy doesn't support headers */(patch307Async(), serviceCallback);
    }

    /**
     * Patch redirected with 307, resulting in a 200 after redirect.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link Void} object if successful.
     */
    public Single<Void> patch307Async() {
        final Boolean booleanValue = null;
        return service.patch307(booleanValue);
    }

    /**
     * Patch redirected with 307, resulting in a 200 after redirect.
     *
     * @param booleanValue Simple boolean value true
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void patch307(Boolean booleanValue) {
        patch307Async(booleanValue).toBlocking().value();
    }

    /**
     * Patch redirected with 307, resulting in a 200 after redirect.
     *
     * @param booleanValue Simple boolean value true
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> patch307Async(Boolean booleanValue, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody/* RestProxy doesn't support headers */(patch307Async(booleanValue), serviceCallback);
    }

    /**
     * Patch redirected with 307, resulting in a 200 after redirect.
     *
     * @param booleanValue Simple boolean value true
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link Single<Void>} object if successful.
     */
    public Single<Void> patch307Async(Boolean booleanValue) {
        return service.patch307(booleanValue);
    }


    /**
     * Post redirected with 307, resulting in a 200 after redirect.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void post307() {
        post307Async().toBlocking().value();
    }

    /**
     * Post redirected with 307, resulting in a 200 after redirect.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> post307Async(final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody/* RestProxy doesn't support headers */(post307Async(), serviceCallback);
    }

    /**
     * Post redirected with 307, resulting in a 200 after redirect.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link Void} object if successful.
     */
    public Single<Void> post307Async() {
        final Boolean booleanValue = null;
        return service.post307(booleanValue);
    }

    /**
     * Post redirected with 307, resulting in a 200 after redirect.
     *
     * @param booleanValue Simple boolean value true
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void post307(Boolean booleanValue) {
        post307Async(booleanValue).toBlocking().value();
    }

    /**
     * Post redirected with 307, resulting in a 200 after redirect.
     *
     * @param booleanValue Simple boolean value true
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> post307Async(Boolean booleanValue, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody/* RestProxy doesn't support headers */(post307Async(booleanValue), serviceCallback);
    }

    /**
     * Post redirected with 307, resulting in a 200 after redirect.
     *
     * @param booleanValue Simple boolean value true
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link Single<Void>} object if successful.
     */
    public Single<Void> post307Async(Boolean booleanValue) {
        return service.post307(booleanValue);
    }


    /**
     * Delete redirected with 307, resulting in a 200 after redirect.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void delete307() {
        delete307Async().toBlocking().value();
    }

    /**
     * Delete redirected with 307, resulting in a 200 after redirect.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> delete307Async(final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody/* RestProxy doesn't support headers */(delete307Async(), serviceCallback);
    }

    /**
     * Delete redirected with 307, resulting in a 200 after redirect.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link Void} object if successful.
     */
    public Single<Void> delete307Async() {
        final Boolean booleanValue = null;
        return service.delete307(booleanValue);
    }

    /**
     * Delete redirected with 307, resulting in a 200 after redirect.
     *
     * @param booleanValue Simple boolean value true
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void delete307(Boolean booleanValue) {
        delete307Async(booleanValue).toBlocking().value();
    }

    /**
     * Delete redirected with 307, resulting in a 200 after redirect.
     *
     * @param booleanValue Simple boolean value true
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> delete307Async(Boolean booleanValue, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody/* RestProxy doesn't support headers */(delete307Async(booleanValue), serviceCallback);
    }

    /**
     * Delete redirected with 307, resulting in a 200 after redirect.
     *
     * @param booleanValue Simple boolean value true
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link Single<Void>} object if successful.
     */
    public Single<Void> delete307Async(Boolean booleanValue) {
        return service.delete307(booleanValue);
    }


}
